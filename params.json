{
  "name": "Synth",
  "tagline": "C++ modular synthesizer",
  "body": "# Synth\r\n\r\n\"Synth\" is a modular synthesizer using PortAudio as backend, inspired\r\nby the WebAudio API.\r\n\r\nI made it because I was looking for a modular synthesis library for modern C++\r\nand found nothing (eh, there was something, but too high level, or written\r\nin ol C or C++). This lib will be revolutionary, but at least it's open source\r\nand the model looks quite friendly.\r\n\r\n## How does that work ?\r\n\r\nThe \"sketch\" test in the test folder is subject to change, but the basics of\r\nfiring up a context and throwing audio waves at your speakers are there. All\r\nthe definitions are found in the `audio::` namespace.\r\n\r\n### audio::Context\r\n\r\nFirst, you need a `audio::Context`. From that class you can fetch information about\r\naudio devices or apis used. It also contains pointers to `audio::Node`s and `audio::Device`s in\r\nuse, but we'll check the `audio::Node`s after.\r\n\r\n### audio::Device\r\n\r\nNow you want an output `audio::Device` (for now it can only be output tho). The ideal\r\nis to find out what is the default device to use with your api of choice. In\r\n`sketch.cpp` I'm using the default device of the first `audio::HostApi` listed by the\r\n`audio::Context`. Just do it like this :\r\n\r\n\t// Get the list of host apis\r\n\tstd::vector<audio::HostApi> hostApis;\r\n\tcontext.listHostApis(std::back_inserter(hostApis));\r\n\r\n\t// Get default output device index (integer)\r\n\tint devIndex = hostApis[0].defaultOutputDeviceIndex;\r\n\tstd::cout << \"Opening output device \" << devIndex << std::endl;\r\n\taudio::Device& device(&context, devIndex);\r\n\r\nOnce you've got your device, you can / have to :\r\n\r\n* open a stream on it : `device.open(2, 44100)`, using the number of channels\r\nand the sampling rate you require\r\n* start it : `device.start()` to fire up the engine\r\n* stop it : `device.stop()` when you're done and want to restart later\r\n* close it : `device.close()` when you're really done and stopped before\r\n\r\n### audio::Node\r\n\r\nA `audio::Node` is a class (defined as structure because o shit waddup) that is linked\r\nto a `audio::Context` and has a `virtual` method `void update(double sampleRate)`. It\r\nshould have multiple `audio::Signal`, representing data to pass around. The update()\r\nmethod is called every 1 / sampleRate seconds by the `audio::Device` currently used (which is\r\nokay for now but I sense trouble with multiple devices :/). That's how you create an\r\n`audio::Oscillator` node for instance :\r\n\r\n\taudio::Oscillator osc(&context);\r\n\tosc.frequency.value = 100.0;\r\n\tosc.shape.value = 0.0f;\r\n\r\nThe `audio::Device` object contains an output `audio::Node` for you to use as sink. The\r\noutput is an `audio::Mixer` node :\r\n\r\n\tosc.destination.connect(&device.output[0]);\r\n\r\nThe `audio::Mixer` node has multiple inputs and writes to \"left\" and \"right\" phases, usable\r\nfor the Device's stereo output (so yes, you can choose channels but there's a fixed amount\r\nof 2 that will be processed, so even mono won't work correctly, yey).\r\nWhen you \"ask\" for index 0 in output, you ask the `audio::Mixer` to initialize one new input\r\n`audio::Signal` at that index. The mixer will gently add up the inputs. And I'll make params\r\nlike panning, volume control later. It just mixes signals altogether for now.\r\n\r\n### A note on audio::Signal\r\n\r\nAs you may have seen, `audio::Signal` behave weirdly. It's not just a structure to a value, it\r\ncan be linked to an other `audio::Signal` to create chains, and make up the audio path. You should\r\ncheck the `audio::Gain` node for a really simple example of the mechanism (in `include/nodes/gain.hpp`).\r\n\r\n\t// Gain derives from Node\r\n\tstruct Gain : Node {\r\n\t\tSignal input;\t\t\t// Input signal\r\n\t\tSignal gain;\t\t\t// Gain factor\r\n\t\tSignal destination;\t\t// Output signal\r\n\r\n\t\t// Constructor\r\n\t\tGain(Context* context) : Node(context) {}\r\n\r\n\t\t// Update method\r\n\t\tvirtual void update(double sampleRate) override {\r\n\t\t\t// Set the value of destination to be input * gain factor\r\n\t\t\tdestination.value = input.value * gain.value;\r\n\r\n\t\t\t// Update the destination value\r\n\t\t\tdestination.update();\r\n\t\t}\r\n\t};\r\n\r\nEach time you make a call to `audio::Signal::update()`, the node copies its value to a list\r\nof targets it has been connected to. That's what you do when you connect the oscillator to\r\nthe output mixer for example. You route the destination of the oscillator to an input of the\r\nmixer.\r\n\r\n## Build\r\n\r\nYou need PortAudio installed to build this library. I should use a dependency system with cmake\r\nin order to incorporate source and let you build it, but you'll have to wait for that. For now,\r\njust install it :\r\n\r\n* on Linux : [apt-get install / pacman -S / yaourt -S / whatever] portaudio\r\n* on Windows : [this git page](https://github.com/adfernandes/precompiled-portaudio-windows) has precompiled binaries\r\n* on Mac OS X : [this page](http://macappstore.org/portaudio/) tells you how to do\r\n* on anything supported : [the portaudio documentation](http://portaudio.com/docs/v19-doxydocs/tutorial_start.html) tells you how to build the library.\r\n\r\nAnd then:\r\n\r\n\tmkdir build\r\n\tcd build\r\n\tcmake .. && make\r\n\r\nIf you want to try the demo :\r\n\r\n\tcd build\r\n\ttest/sketch/sketch\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}