<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Synth by brainsandwich</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Synth</h1>
        <p>C++ modular synthesizer</p>

        <p class="view"><a href="https://github.com/brainsandwich/synth">View the Project on GitHub <small>brainsandwich/synth</small></a></p>


        <ul>
          <li><a href="https://github.com/brainsandwich/synth/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/brainsandwich/synth/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/brainsandwich/synth">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h1>
<a id="synth" class="anchor" href="#synth" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Synth</h1>

<p>"Synth" is a modular synthesizer using PortAudio as backend, inspired
by the WebAudio API.</p>

<p>I made it because I was looking for a modular synthesis library for modern C++
and found nothing (eh, there was something, but too high level, or written
in ol C or C++). This lib will be revolutionary, but at least it's open source
and the model looks quite friendly.</p>

<h2>
<a id="how-does-that-work-" class="anchor" href="#how-does-that-work-" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How does that work ?</h2>

<p>The "sketch" test in the test folder is subject to change, but the basics of
firing up a context and throwing audio waves at your speakers are there. All
the definitions are found in the <code>audio::</code> namespace.</p>

<h3>
<a id="audiocontext" class="anchor" href="#audiocontext" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>audio::Context</h3>

<p>First, you need a <code>audio::Context</code>. From that class you can fetch information about
audio devices or apis used. It also contains pointers to <code>audio::Node</code>s and <code>audio::Device</code>s in
use, but we'll check the <code>audio::Node</code>s after.</p>

<h3>
<a id="audiodevice" class="anchor" href="#audiodevice" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>audio::Device</h3>

<p>Now you want an output <code>audio::Device</code> (for now it can only be output tho). The ideal
is to find out what is the default device to use with your api of choice. In
<code>sketch.cpp</code> I'm using the default device of the first <code>audio::HostApi</code> listed by the
<code>audio::Context</code>. Just do it like this :</p>

<pre><code>// Get the list of host apis
std::vector&lt;audio::HostApi&gt; hostApis;
context.listHostApis(std::back_inserter(hostApis));

// Get default output device index (integer)
int devIndex = hostApis[0].defaultOutputDeviceIndex;
std::cout &lt;&lt; "Opening output device " &lt;&lt; devIndex &lt;&lt; std::endl;
audio::Device&amp; device(&amp;context, devIndex);
</code></pre>

<p>Once you've got your device, you can / have to :</p>

<ul>
<li>open a stream on it : <code>device.open(2, 44100)</code>, using the number of channels
and the sampling rate you require</li>
<li>start it : <code>device.start()</code> to fire up the engine</li>
<li>stop it : <code>device.stop()</code> when you're done and want to restart later</li>
<li>close it : <code>device.close()</code> when you're really done and stopped before</li>
</ul>

<h3>
<a id="audionode" class="anchor" href="#audionode" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>audio::Node</h3>

<p>A <code>audio::Node</code> is a class (defined as structure because o shit waddup) that is linked
to a <code>audio::Context</code> and has a <code>virtual</code> method <code>void update(double sampleRate)</code>. It
should have multiple <code>audio::Signal</code>, representing data to pass around. The update()
method is called every 1 / sampleRate seconds by the <code>audio::Device</code> currently used (which is
okay for now but I sense trouble with multiple devices :/). That's how you create an
<code>audio::Oscillator</code> node for instance :</p>

<pre><code>audio::Oscillator osc(&amp;context);
osc.frequency.value = 100.0;
osc.shape.value = 0.0f;
</code></pre>

<p>The <code>audio::Device</code> object contains an output <code>audio::Node</code> for you to use as sink. The
output is an <code>audio::Mixer</code> node :</p>

<pre><code>osc.destination.connect(&amp;device.output[0]);
</code></pre>

<p>The <code>audio::Mixer</code> node has multiple inputs and writes to "left" and "right" phases, usable
for the Device's stereo output (so yes, you can choose channels but there's a fixed amount
of 2 that will be processed, so even mono won't work correctly, yey).
When you "ask" for index 0 in output, you ask the <code>audio::Mixer</code> to initialize one new input
<code>audio::Signal</code> at that index. The mixer will gently add up the inputs. And I'll make params
like panning, volume control later. It just mixes signals altogether for now.</p>

<h3>
<a id="a-note-on-audiosignal" class="anchor" href="#a-note-on-audiosignal" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A note on audio::Signal</h3>

<p>As you may have seen, <code>audio::Signal</code> behave weirdly. It's not just a structure to a value, it
can be linked to an other <code>audio::Signal</code> to create chains, and make up the audio path. You should
check the <code>audio::Gain</code> node for a really simple example of the mechanism (in <code>include/nodes/gain.hpp</code>).</p>

<pre><code>// Gain derives from Node
struct Gain : Node {
    Signal input;           // Input signal
    Signal gain;            // Gain factor
    Signal destination;     // Output signal

    // Constructor
    Gain(Context* context) : Node(context) {}

    // Update method
    virtual void update(double sampleRate) override {
        // Set the value of destination to be input * gain factor
        destination.value = input.value * gain.value;

        // Update the destination value
        destination.update();
    }
};
</code></pre>

<p>Each time you make a call to <code>audio::Signal::update()</code>, the node copies its value to a list
of targets it has been connected to. That's what you do when you connect the oscillator to
the output mixer for example. You route the destination of the oscillator to an input of the
mixer.</p>

<h2>
<a id="build" class="anchor" href="#build" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Build</h2>

<p>You need PortAudio installed to build this library. I should use a dependency system with cmake
in order to incorporate source and let you build it, but you'll have to wait for that. For now,
just install it :</p>

<ul>
<li>on Linux : [apt-get install / pacman -S / yaourt -S / whatever] portaudio</li>
<li>on Windows : <a href="https://github.com/adfernandes/precompiled-portaudio-windows">this git page</a> has precompiled binaries</li>
<li>on Mac OS X : <a href="http://macappstore.org/portaudio/">this page</a> tells you how to do</li>
<li>on anything supported : <a href="http://portaudio.com/docs/v19-doxydocs/tutorial_start.html">the portaudio documentation</a> tells you how to build the library.</li>
</ul>

<p>And then:</p>

<pre><code>mkdir build
cd build
cmake .. &amp;&amp; make
</code></pre>

<p>If you want to try the demo :</p>

<pre><code>cd build
test/sketch/sketch
</code></pre>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/brainsandwich">brainsandwich</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
